<!DOCTYPE html>
<html>

<head>
    <title>AI EV Optimizer - Real-Time Optimization</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        body { margin: 0; display: flex; background: #0b0b0b; color: white; font-family: sans-serif; height: 100vh; overflow: hidden; }
        #side { width: 30%; padding: 20px; border-right: 1px solid #333; background: #151515; text-align: center; }
        #map-panel { width: 70%; position: relative; }
        #map-canvas { height: 100%; width: 100%; }
        .video { width: 100%; border-radius: 10px; border: 2px solid #444; }
        #status-bar { padding: 15px; margin-top: 15px; border-radius: 8px; font-weight: bold; }
        .safe { background: #2ecc71; }
        .danger { background: #e74c3c; animation: pulse 1s infinite; }
        #controls { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(0, 0, 0, 0.85); padding: 15px; border-radius: 10px; width: 320px; }
        input { width: 100%; padding: 10px; margin-bottom: 5px; background: #222; color: white; border: 1px solid #555; border-radius: 5px; box-sizing: border-box; }
        .suggestions { background: #222; position: absolute; width: 90%; z-index: 2000; max-height: 150px; overflow-y: auto; }
        .sug-item { padding: 8px; cursor: pointer; border-bottom: 1px solid #333; font-size: 12px; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
    </style>
</head>

<body>
    <div id="side">
        <h2>Driver Safety</h2>
        <img class="video" src="{{ url_for('video_feed') }}">
        <div id="status-bar" class="safe">READY</div>
        <div style="text-align:left; margin-top:20px;">
            <p id="dist-txt">Distance: -- km</p>
            <p id="cons-txt" style="color:#2ecc71">Energy: -- kWh</p>
            <p id="route-info" style="font-size: 12px; color: #3498db;"></p>
        </div>
    </div>

    <div id="map-panel">
        <div id="controls">
            <input type="text" id="start" placeholder="Start Location" oninput="debSearch(this, 's-list')">
            <div id="s-list" class="suggestions"></div>
            <input type="text" id="end" placeholder="Destination" oninput="debSearch(this, 'e-list')">
            <div id="e-list" class="suggestions"></div>
            <button onclick="go()" style="width:100%; padding:10px; background:#3498db; color:white; border:none; border-radius:5px; cursor:pointer;">
                OPTIMIZE ROUTE
            </button>
        </div>
        <div id="map-canvas"></div>
    </div>

    <audio id="alarm-sound" loop src="{{ url_for('static', filename='alarm.mp3') }}"></audio>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    
    <script>
        // Map Init
        var map = L.map('map-canvas').setView([12.9344, 80.2130], 11);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        // This layer group holds our custom Green and Blue polylines
        var routePathLayer = L.layerGroup().addTo(map);

        // Setup Routing Engine - CRITICAL: serviceParameters added for REAL alternatives
        var routing = L.Routing.control({
            router: L.Routing.osrmv1({ 
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                serviceParameters: { alternatives: 2 } // Request real alternatives from OSRM
            }),
            lineOptions: { styles: [{ opacity: 0 }] }, // Hide default black line
            show: false,
            addWaypoints: false
        }).addTo(map);

        // Search logic
        let timer;
        function debSearch(i, l) { clearTimeout(timer); timer = setTimeout(() => search(i, l), 600); }
        async function search(input, listId) {
            if (input.value.length < 3) return;
            const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${input.value}&limit=5`);
            const data = await res.json();
            const list = document.getElementById(listId); list.innerHTML = "";
            data.forEach(item => {
                let d = document.createElement("div"); d.className = "sug-item"; d.innerText = item.display_name;
                d.onclick = () => { input.value = item.display_name; input.dataset.lat = item.lat; input.dataset.lon = item.lon; list.innerHTML = ""; };
                list.appendChild(d);
            });
        }

        /**
         * Real Optimization Function
         */
        function go() {
            const s = document.getElementById('start').dataset; 
            const e = document.getElementById('end').dataset;
            
            if (s.lat && e.lat) {
                routePathLayer.clearLayers(); // Wipe previous session
                routing.setWaypoints([L.latLng(s.lat, s.lon), L.latLng(e.lat, e.lon)]);

                routing.on('routesfound', function(event) {
                    var routes = event.routes; 
                    var bestIdx = 0;
                    var minEnergy = Infinity;

                    // REAL MATHEMATICAL OPTIMIZATION LOOP
                    routes.forEach(function(r, i) {
                        let d_km = r.summary.totalDistance / 1000;
                        let t_min = r.summary.totalTime / 60;
                        
                        // Energy Cost Formula: Distance + Traffic Delay
                        let energy = (d_km * 0.15) + (t_min * 0.01); 

                        if (energy < minEnergy) {
                            minEnergy = energy;
                            bestIdx = i;
                        }
                    });

                    // Clear and Redraw
                    routePathLayer.clearLayers();
                    routes.forEach(function(r, i) {
                        if (i !== bestIdx) {
                            // Real alternative path in Blue
                            L.polyline(r.coordinates, {
                                color: '#3498db', weight: 4, opacity: 0.6, dashArray: '5, 10'
                            }).addTo(routePathLayer);
                        }
                    });

                    // Real Optimized path in Green (Drawn last to be on top)
                    L.polyline(routes[bestIdx].coordinates, {
                        color: '#2ecc71', weight: 8, opacity: 1
                    }).addTo(routePathLayer);

                    // Sync the chosen route data
                    routing._selectedRoute = routes[bestIdx];
                    document.getElementById('cons-txt').innerText = "Energy: " + minEnergy.toFixed(2) + " kWh";
                    document.getElementById('route-info').innerText = routes.length > 1 ? 
                        "Status: Least Energy Route Selected" : "Status: Single Route Available";
                });
            }
        }

        const alarm = document.getElementById('alarm-sound');
        let canPlay = false; document.addEventListener('click', () => canPlay = true, { once: true });

        async function sync() {
            try {
                const activeRoute = routing._selectedRoute;
                if (!activeRoute) return;
                
                let currentKm = (activeRoute.summary.totalDistance / 1000).toFixed(2);
                const res = await fetch(`/get_system_data?dist=${currentKm}`);
                const data = await res.json();

                const bar = document.getElementById('status-bar');
                if (["Alert", "Looking Side", "Calibrating..."].includes(data.status)) {
                    bar.innerText = "STATUS: " + data.status.toUpperCase(); bar.className = "safe"; alarm.pause();
                } else {
                    bar.innerText = "WARNING: " + data.status.toUpperCase(); bar.className = "danger";
                    if (canPlay) alarm.play().catch(() => { });
                }
                document.getElementById('dist-txt').innerText = "Distance: " + currentKm + " km";
            } catch (e) { }
        }
        setInterval(sync, 1000);
    </script>
</body>
</html>